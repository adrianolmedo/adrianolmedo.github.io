[{"contents":"goplantuml genera un código en formato PlantUML que representa un diagrama de las relaciones entre las estructuras receptoras de Go que son análogas a las clases en la OOP tradicional.\nUna herramienta útil al comienzo del diseño y planificación de un proyecto complejo en Go si deseas de manera gráfica observar cúales entidades están pisando interfaces, seguir visualmente inyecciones de dependencia o identificar patrones.\nSi tu proyecto es plano sin paquetes $ goplantuml -aggregate-private-members -show-compositions -show-implementations -show-aggregations . \u0026gt; diagram.puml Si tu proyecto tiene paquetes $ goplantuml -aggregate-private-members -show-compositions -show-implementations -show-aggregations ./ \u0026gt; diagram.puml ","date":"23","image":"images/post/06.jpg","permalink":"https://examplesite.org/es/blog/como-usar-goplantuml/","tags":["uml","poo"],"title":"¿Cómo usar GoPlantUML?"},{"contents":" Below is a full Spanish translation of an William Kennedy's post in Ardan labs Blog: Avoid Interface Pollution.\n  Introducción Las interfaces solo deben utilizarse cuando su valor añadido sea claro. Veo demasiados paquetes que declaran interfaces innecesariamente, a veces solo por usar interfaces. El uso de interfaces cuando no son necesarias se denomina contaminación de interfaces. Esta es una práctica que me gustaría ver cuestionada e identificada más en las revisiones de código.\nCódigo de Ejemplo Veamos un ejemplo de código que contiene decisiones de diseño cuestionables que generan señales de Interface Pollution.\n01 package tcp 02 03 // Server defines a contract for tcp servers. 04 type Server interface { 05 Start() error 06 Stop() error 07 Wait() error 08 } 09 10 // server is our Server implementation. 11 type server struct { 12 /* impl */ 13 } 14 15 // NewServer returns an interface value of type Server 16 // with an xServer implementation. 17 func NewServer(host string) Server { 18 return \u0026amp;server{host} 19 } 20 21 // Start allows the server to begin to accept requests. 22 func (s *server) Start() error { 23 /* impl */ 24 } 25 26 // Stop shuts the server down. 27 func (s *server) Stop() error { 28 /* impl */ 29 } 30 31 // Wait prevents the server from accepting new connections. 32 func (s *server) Wait() error { 33 /* impl */ 34 } Aquí está la lista de olores de Pollution Interface del código anterior:\n El paquete declara una interfaz que coincide con toda la API de su propio tipo concreto. La función factory devuelve el valor de la interfaz con el valor del tipo de estructura no exportada dentro. La interfaz se puede eliminar y nada cambia para el usuario de la API. La interfaz no desacopla la API del cambio.  Analicemos el código:\nEn la línea 04 vemos una declaración de interfaz exportada Server. Esta interfaz declara una duplicación exacta de la API declarada por server de tipo concreto no exportado en la línea 11. Estas dos líneas de código marcan la casilla de los elementos 1 en la lista de olores.\nLuego, en la línea 17 vemos la función factory NewServer. Esta función crea un valor de server de tipo concreto no exportado y lo devuelve al usuario dentro de un valor de interfaz exportado de tipo Server. Esto marca la casilla del elemento 2 en la lista de olores.\nLa siguiente lista de códigos muestra cómo la eliminación de la interfaz no cambia nada para el usuario:\n10 // Remove the interface and change the concrete type to be exported. 11 type Server struct { 12 /* impl */ 13 } 14 15 // Have the NewServer function return a pointer of the concrete type instead 16 // of the interface type. 17 func NewServer(host string) *Server { 18 return \u0026amp;Server{host} 19 } Hacer que el usuario trabaje directamente con el tipo concreto no cambia nada para el usuario ni para la API. Este cambio realmente ha mejorado las cosas porque se ha eliminado el nivel adicional de direccionamiento indirecto para llamar a los métodos a través del valor de la interfaz. Esto marca la casilla del elemento 3 en la lista de olores.\nFinalmente, si preguntamos qué puede cambiar en el código, nunca habrá una nueva implementación de Server. Tener una interfaz para desacoplar el tipo de estructura server de la API no ayuda a la API a desacoplarse del cambio. Esto marca la casilla final para el elemento 4 en la lista de olores.\nConclusión Aquí hay algunas pautas que puede seguir para validar y cuestionar el uso de interfaces en su código:\nUse una interfaz:\n Cuando los usuarios de la API necesitan proporcionar un detalle de implementación (?). Cuando las API tienen varias implementaciones, necesitan mantenerla internamente. Cuando se han identificado partes de la API que pueden cambiar y requieren desacoplamiento.   References\nK. William. (Oct 21, 2016). Avoid Interface Pollution. https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html\n","date":"15","image":"images/post/03.jpg","permalink":"https://examplesite.org/es/blog/polucion-de-interfaces/","tags":["translated","advices","oop"],"title":"Polución de interfaces"},{"contents":" Below is a full Spanish translation of Rob Pike's original post on his personal Blogger: Less is exponentially more.\n  Aquí está el texto de la charla que di en la reunión de Go SF en junio de 2012.\nEsta es una charla personal. No hablo por nadie más en el equipo de Go aquí, aunque quiero reconocer desde el principio que el equipo es lo que hizo y sigue haciendo que Go suceda. También me gustaría agradecer a los organizadores de Go SF por darme la oportunidad de hablar con ustedes.\nHace unas semanas me preguntaron: \u0026ldquo;¿Cuál fue la mayor sorpresa que encontraste al implementar Go?\u0026rdquo; Supe la respuesta al instante: aunque esperábamos que los programadores de C++ vieran Go como una alternativa, en cambio, la mayoría de los programadores de Go provienen de lenguajes como Python y Ruby. Muy pocos proceden de C++.\nNosotros, —Ken, Robert y yo—, éramos programadores de C++ cuando diseñamos un nuevo lenguaje para resolver los problemas que creíamos que debían resolverse para el tipo de software que escribimos. Parece casi paradójico que a otros programadores de C++ no les importe.\nMe gustaría hablar hoy sobre lo que nos impulsó a crear Go y por qué el resultado no debería habernos sorprendido así. Prometo que esto será más sobre Go que sobre C++, y que si no conoces C++ podrás seguirlo.\nLa respuesta se puede resumir así: ¿Crees que menos es más o menos es menos?\nAquí hay una metáfora, en forma de historia real. A Bell Labs centers le asignaron originalmente números de tres letras: 111 para Investigación en Física, 127 para Investigación en Ciencias de la Computación, y así sucesivamente. A principios de la década de 1980, apareció un memorando anunciando que a medida que nuestra comprensión de la investigación había aumentado, se había hecho necesario agregar otro dígito para poder caracterizar mejor nuestro trabajo. Así que nuestro centro se convirtió en 1127. Ron Hardin bromeó, medio en serio, que si realmente entendiéramos nuestro mundo mejor, podríamos bajar un dígito y pasar de 127 a solo 27. Por supuesto, la gerencia no entendió la broma, ni tampoco la esperaba, pero creo que hay sabiduría en ello. Menos puede ser más. Cuanto mejor entiendas, más conciso podrás ser.\nTenga esa idea en mente.\nAlrededor de septiembre de 2007, estaba haciendo un trabajo menor pero central en un enorme programa de Google C++, uno con el que todos habéis interactuado, y mis compilaciones tardaban unos 45 minutos en nuestro enorme grupo de compilación distribuido. Se anunció que iba a haber una charla presentada por un par de empleados de Google que forman parte del comité de estándares de C++. Nos iban a decir lo que vendría en C++ 0x, como se llamaba en ese momento. (Ahora se conoce como C++ 11).\nEn el lapso de una hora en esa charla, escuchamos acerca de unas 35 funciones nuevas que se estaban planificando. De hecho hubo muchos más, pero solo 35 fueron descritos en la charla. Algunas de las características eran menores, por supuesto, pero las de la charla eran al menos lo suficientemente significativas como para llamar la atención. Algunas eran muy sutiles y difíciles de entender, como las referencias de rvalue, mientras que otras son especialmente similares a C++, como las variadic templates, y otras son simplemente locas, como literales definidos por el usuario.\nEn este punto me hice una pregunta: ¿El comité de C++ realmente creía que lo malo de C++ era que no tenía suficientes funciones? Seguramente, en una variante del chiste de Ron Hardin, sería un mayor logro simplificar el lenguaje en lugar de agregarle más. Por supuesto, eso es ridículo, pero tenga en cuenta la idea.\nSolo unos meses antes de esa charla de C++, yo mismo había dado una charla, que puedes ver en YouTube, sobre un lenguaje concurrente de juguete que había construido en la década de 1980. Ese lenguaje se llamó Newsqueak y por supuesto es un precursor de Go.\nDi esa charla porque había ideas en Newsqueak que extrañaba en mi trabajo en Google y había estado pensando en ellas nuevamente. Estaba convencido de que facilitarían la escritura del código del servidor y Google realmente podría beneficiarse de eso.\nDe hecho, intenté y no pude encontrar una manera de llevar las ideas a C++. Era demasiado difícil acoplar las operaciones concurrentes con las estructuras de control de C++ y, a su vez, eso dificultaba ver las ventajas reales. Además, C++ hizo que todo pareciera demasiado engorroso, aunque admito que nunca fui realmente fácil en el lenguaje. Entonces abandoné la idea.\nPero la charla de C++ 0x me hizo pensar de nuevo. Una cosa que realmente me molestó, y creo que Ken y Robert también, fue el nuevo modelo de memoria C++ con tipos atómicos. Simplemente se sentía mal poner un conjunto de detalles tan definidos microscópicamente en un sistema de tipos que ya estaba sobrecargado. También parecía miope, ya que es probable que el hardware cambie significativamente en la próxima década y no sería prudente acoplar demasiado el lenguaje al hardware actual.\nRegresamos a nuestras oficinas después de la charla. Comencé otra compilación, giré mi silla para mirar a Robert y comencé a hacer preguntas directas. Antes de que terminara la compilación, atamos a Ken y decidimos hacer algo. No queríamos escribir en C++ para siempre, y nosotros, —especialmente yo—, queríamos tener la simultaneidad al alcance de mi mano al escribir código de Google. También queríamos abordar el problema de la \u0026ldquo;programación en grande\u0026rdquo; de frente, del que hablaremos más adelante.\nEscribimos en la pizarra un montón de cosas que queríamos, desiderata si se quiere. Pensamos en grande, ignorando la sintaxis y la semántica detalladas y centrándonos en el panorama general.\nTodavía tengo un hilo de correo fascinante de esa semana. Aquí hay un par de extractos:\nRobert:\n Punto de partida: C, corregir algunos defectos obvios, eliminar la suciedad, agregar algunas características que faltan.\n Rob:\n nombre: \u0026lsquo;go\u0026rsquo;. puedes inventar razones para este nombre, pero tiene buenas propiedades. es breve y fácil de escribir. tools: goc, gol, goa. si hay un depurador / intérprete interactivo, podría simplemente llamarse \u0026lsquo;go\u0026rsquo;. el sufijo es .go.\n Robert:\n Interfaces vacías: interface{}. Estos son implementados por todas las interfaces y, por lo tanto, esto podría reemplazar a void*.\n No lo resolvimos todo de inmediato. Por ejemplo, nos llevó más de un año descubrir arrays y slices. Pero una gran parte del sabor del lenguaje surgió en esos primeros días.\nObserve que Robert dijo que C era el punto de partida, no C++. No estoy seguro, pero creo que se refería a C propiamente dicho, especialmente porque Ken estaba allí. Pero también es cierto que, al final, en realidad no partimos de C. Creamos desde cero, tomando prestadas solo cosas menores como operadores y corchetes y algunas palabras clave comunes. (Y, por supuesto, también tomamos prestadas ideas de otros lenguajes que conocíamos). En cualquier caso, ahora veo que reaccionamos a C++ volviendo a lo básico, descomponiéndolo todo y comenzando de nuevo. No estábamos tratando de diseñar un C++ mejor, ni siquiera un C mejor. Se trataba de un lenguaje mejor en general para el tipo de software que nos importaba.\nAl final, por supuesto, resultó bastante diferente de C o C++. Más diferente incluso de lo que muchos creen. Hice una lista de simplificaciones significativas en Go sobre C y C++:\n        - sintaxis regular (no se necesita una tabla de símbolos para analizar)   - recolección de basura (solo)   - sin archivos de encabezado   - dependencias explícitas   - sin dependencias circulares   - las constantes son solo números   - int e int32 son tipos distintos   - case letters establece visibilidad   - métodos para cualquier tipo (sin clases)   - sin herencia de subtipos (sin subclases)   - init a nivel de paquete y orden de init bien definido   - archivos compilados juntos en un paquete   - globales a nivel de paquete presentados en cualquier orden   - sin conversiones aritméticas (las constantes ayudan)   - las interfaces son implícitas (sin declaración de \u0026ldquo;implements\u0026rdquo;)   - incrustación (sin promoción a superclase)   - los métodos se declaran como funciones (sin ubicación especial)   - los métodos son solo funciones   - las interfaces son solo métodos (sin datos)   - los métodos coinciden solo por nombre (no por tipo)   - sin constructores ni destructores   - el poscremento y el posdecremento son declaraciones, no expresiones   - sin preincremento o predecremento   - la asignación no es una expresión   - orden de evaluación definido en la asignación, llamada de función (sin \u0026ldquo;punto de secuencia\u0026rdquo;)   - sin aritmética de puntero   - la memoria siempre está a cero   - legal para tomar la dirección de la variable local   - no \u0026ldquo;this\u0026rdquo; en los métodos   - pilas segmentadas   - sin const u otro tipo de anotaciones   - sin plantillas   - sin excepciones   - builtin string, slice, map   - comprobación de límites en arrays    Y, sin embargo, con esa larga lista de simplificaciones y piezas faltantes, Go es, creo, más expresivo que C o C++. Menos puede ser más.\nPero no puedes sacarlo todo. Necesita componentes básicos como una idea sobre cómo se comportan los tipos, una sintaxis que funcione bien en la práctica y algo inefable que haga que las bibliotecas interoperen bien.\nUna cosa que está notoriamente ausente es, por supuesto, una jerarquía de tipos. Permítame ser grosero con eso por un minuto.\nAl principio del lanzamiento de Go, alguien me dijo que no podía imaginarse trabajando en un idioma sin tipos genéricos. Como he informado en otra parte, me pareció un comentario extraño.\nPara ser justos, probablemente estaba diciendo a su manera que realmente le gustaba lo que STL hace por él en C++. Sin embargo, para el propósito de la discusión, consideremos su afirmación al pie de la letra.\nLo que dice es que para él escribir contenedores como listas de entradas y mapas de cadenas es una carga insoportable. Encuentro que es una afirmación extraña. Paso muy poco de mi tiempo de programación luchando con esos problemas, incluso en lenguajes sin tipos genéricos.\nPero lo que es más importante, lo que dice es que los tipos son la forma de aliviar esa carga. Tipos. No funciones polimórficas o primitivas del lenguaje o ayudantes de otro tipo, sino tipos.\nEse es el detalle que me queda grabado.\nLos programadores que vienen a Go desde C++ y Java pierden la idea de programar con tipos, particularmente herencia y subclases y todo eso. Quizás soy un filisteo con los tipos, pero nunca he encontrado ese modelo particularmente expresivo.\nMi difunto amigo Alain Fournier me dijo una vez que consideraba que la taxonomía es la forma más baja de trabajo académico. ¿Y sabes qué? Las jerarquías de tipos son solo taxonomía. Debe decidir qué pieza va en qué caja, el padre de cada tipo, si A hereda de B o B de A. ¿Es una matriz ordenable una matriz que ordena o un clasificador representado por una matriz? Si cree que los tipos abordan todos los problemas de diseño, debe tomar esa decisión.\nCreo que es una forma absurda de pensar en la programación. Lo que importa no son las relaciones ancestrales entre las cosas, sino lo que pueden hacer por ti.\nEso, por supuesto, es donde entran las interfaces en Go. Pero son parte de un panorama más amplio, la verdadera filosofía de Go.\nSi C++ y Java se tratan de jerarquías de tipos y la taxonomía de tipos, Go se trata de composición.\nDoug McIlroy, el eventual inventor de las Unix pipes, escribió en 1964 (!):\n Deberíamos tener algunas formas de acoplar programas como la manguera de jardín: atornille en otro segmento cuando sea necesario masajear los datos de otra manera. Esta es también la forma de IO.\n Ese es el camino de Go también. Go toma esa idea y la lleva muy lejos. Es un lenguaje de composición y acoplamiento.\nEl ejemplo obvio es la forma en que las interfaces nos dan la composición de los componentes. No importa qué es esa cosa, si implementa el método M, puedo dejarlo aquí.\nOtro ejemplo importante es cómo la concurrencia nos da la composición de cálculos que se ejecutan de forma independiente.\nE incluso hay una forma inusual (y muy simple) de composición tipográfica: incrustación.\nEstas técnicas de composición son las que le dan a Go su sabor, que es profundamente diferente del sabor de los programas C++ o Java.\n Hay un aspecto no relacionado del diseño de Go que me gustaría mencionar: Go fue diseñado para ayudar a escribir grandes programas, escritos y mantenidos por grandes equipos.\nExiste esta idea sobre \u0026ldquo;programar en grande\u0026rdquo; y de alguna manera C++ y Java poseen ese dominio. Creo que es solo un accidente histórico, o quizás un accidente industrial. Pero la creencia generalizada es que tiene algo que ver con el diseño orientado a objetos.\nNo me lo creo en absoluto. El gran software necesita metodología para estar seguro, pero no tanto como necesita una sólida gestión de dependencias y una abstracción de interfaz limpia y excelentes herramientas de documentación, ninguna de las cuales funciona bien con C++ (aunque Java lo hace notablemente mejor).\nNo lo sabemos todavía, porque no se ha escrito suficiente software en Go, pero estoy seguro de que Go resultará ser un excelente lenguaje para la programación en general. El tiempo dirá.\n Ahora, para volver a la sorprendente pregunta que abrió mi charla:\n¿Por qué Go, un lenguaje diseñado desde cero para lo que se usa C++, no atrae a más programadores de C++?\nBromas aparte, creo que es porque Go y C++ son filosóficamente profundamente diferentes.\nC++ consiste en tenerlo todo al alcance de la mano. Encontré esta cita en una pregunta frecuente de C++ 11:\n La gama de abstracciones que C++ puede expresar de forma elegante, flexible y sin costes en comparación con el código especializado elaborado a mano ha aumentado considerablemente.\n Esa forma de pensar no es la forma en que funciona Go. El costo cero no es un objetivo, al menos no el costo de CPU cero. La afirmación de Go es que minimizar el esfuerzo del programador es una consideración más importante.\nGo no lo abarca todo. No tiene todo integrado. No tiene un control preciso de cada matiz de ejecución. Por ejemplo, no tienes RAII. En su lugar, obtienes un recolector de basura. Ni siquiera obtienes una función para liberar memoria.\nLo que se le proporciona es un conjunto de bloques de construcción poderosos pero fáciles de entender y de usar a partir de los cuales puede ensamblar, componer, una solución a su problema. Puede que no termine tan rápido o tan sofisticado o tan ideológicamente motivado como la solución que escribiría en algunos de esos otros idiomas, pero es casi seguro que será más fácil de escribir, más fácil de leer, más fácil de entender, más fácil de escribir. mantener, y tal vez más seguro.\nPara decirlo de otra manera, simplificando demasiado, por supuesto:\nLos programadores de Python y Ruby vienen a Go porque no tienen que renunciar a mucha expresividad, sino que obtienen rendimiento y se ponen a jugar con la concurrencia.\nLos programadores de C++ no vienen a Go porque hayan luchado duro para obtener un control exquisito de su dominio de programación y no quieren ceder nada de eso. Para ellos, el software no se trata solo de hacer el trabajo, se trata de hacerlo de cierta manera.\nEl problema, entonces, es que el éxito de Go contradeciría su visión del mundo.\nY deberíamos habernos dado cuenta de eso desde el principio. A las personas que están entusiasmadas con las nuevas características de C++ 11 no les va a importar un lenguaje que tenga mucho menos. Incluso si, al final, ofrece mucho más.\nGracias.\n References\nP. Rob. (Jun 25, 2012). Less is exponentially more. command center. https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html\n","date":"15","image":"images/post/05.jpg","permalink":"https://examplesite.org/es/blog/menos-es-potencialmente-mas/","tags":["translated","advices","oop"],"title":"Menos es potencialmente más"},{"contents":"ffmpeg es una herramienta que además de permitir la conversion de formato de archivos multimedia también puedes grabar vídeo pantalla partiendo desde la interfaz de terminal.\nEste tutorial lo hice con la version n4.1.4, si quieres saber qué versión estás corriendo usa el flag -version:\n$ ffmpeg -version ffmpeg version n4.1.4 Copyright (c) 2000-2019 the FFmpeg developers built with gcc 7 (Ubuntu 7.4.0-1ubuntu1~18.04.1) configuration: --prefix= --prefix=/usr --disable-debug --disable-doc --disable-static --enable-avisynth --enable-cuda --enable-cuvid --enable-libdrm --enable-ffplay --enable-gnutls --enable-gpl --enable-libass --enable-libfdk-aac --enable-libfontconfig --enable-libfreetype --enable-libmp3lame --enable-libopencore_amrnb --enable-libopencore_amrwb --enable-libopus --enable-libpulse --enable-sdl2 --enable-libspeex --enable-libtheora --enable-libtwolame --enable-libv4l2 --enable-libvorbis --enable-libvpx --enable-libx264 --enable-libx265 --enable-libxcb --enable-libxvid --enable-nonfree --enable-nvenc --enable-omx --enable-openal --enable-opencl --enable-runtime-cpudetect --enable-shared --enable-vaapi --enable-vdpau --enable-version3 --enable-xlib libavutil 56. 22.100 / 56. 22.100 libavcodec 58. 35.100 / 58. 35.100 libavformat 58. 20.100 / 58. 20.100 libavdevice 58. 5.100 / 58. 5.100 libavfilter 7. 40.101 / 7. 40.101 libswscale 5. 3.100 / 5. 3.100 libswresample 3. 3.100 / 3. 3.100 libpostproc 55. 3.100 / 55. 3.100 Grabar sólo vídeo Bota un archivo .mp4 ideal para reproductores genéricos:\n$ ffmpeg -f x11grab -r 30 -s 1024x768 -i :0.0 record1.mp4 Explicación:\nffmpeg // inicializamos el comando ffmpeg  -f x11grab // fuente para la pantalla  -r 30 // frames por segundo  -s 1024x768 // resolución de pantalla  -i :0.0 // input de la pantlla  record1.mp4\t// nombre del vídeo con su respectivo formato Puedes añadir -pix_fmt yuv420p, hace que la salida ffmpeg sea a un formato de pixel estándar que todos los reproductores puedan mostrar:\n$ ffmpeg -f x11grab -r 30 -s 1024x768 -i :0.0 -pix_fmt yuv420p output.mp4 Grabar vídeo con audio interno y micrófono Primero debes saber las fuentes de sonido con el comando $ ffmpeg -sources, luego aparecerá con un * para alsa (si está instalado) o pulse (pulseaudio), ejemplo en mi caso:\n$ ffmpeg -sources Auto-detected sources for pulse: * alsa_output.pci-0000_00_1b.0.analog-stereo.monitor [Monitor of Audio Interno Estéreo analógico]  alsa_input.pci-0000_00_1b.0.analog-stereo [Audio Interno Estéreo analógico]  alsa_output.pci-0000_01_00.0.analog-stereo.monitor [Monitor of CMI8738/CMI8768 PCI Audio (CMI8738/C3DX PCI Audio Device) Estéreo analógico]  alsa_input.pci-0000_01_00.0.analog-stereo [CMI8738/CMI8768 PCI Audio (CMI8738/C3DX PCI Audio Device) Estéreo analógico] Si verificas con el mezclador gráfico de audio, verás que se recibe entrada de audio desde el micrófono en \u0026lsquo;Audio Interno Estéreo analógico\u0026rsquo;.\nffmpeg // inicializamos el comando ffmpeg  -f pulse // instancie el backend de audio -i alsa_input.pci-0000_00_1b.0.analog-stereo // seleccione primera fuente de audio  -f pulse // instance nuevamente el backend de audio -i alsa_output.pci-0000_00_1b.0.analog-stereo.monitor // seleccione segunda fuente de audio  -f x11grab // fuente para la pantalla -r 30 // fps (a veces puede ser 60) -s 1024x768 // resolución de pantalla -i :0.0 // input de la pantlla -c:a mp3\t// codec de audio (no es necesario) -b:i 5M // velocidad de grabacón (5mps) -ac 2 // canales de audio (2 para estéreo, anque ya viene así por defecto) -async 25 // sincronización de audios y video (a veces recomiendan 1 o 1000) -filter_complex amix=inputs=2\t// sincroniza las dos fuentes de audio -pix_fmt yuv420p // standard pixel format that all players can show record1.mkv // nombre del vídeo con su respectivo formato - Versión 1 (funcionó):\n$ ffmpeg -f pulse -i alsa_input.pci-0000_00_1b.0.analog-stereo -f x11grab -r 30 -s 1024x768 -i :0.0 -ac 2 -async 25 -filter_complex amix=inputs=1 record3.mp4 Graba bien el audio del micrófono pero no el audio interno, por ejemplo: reproducción desde YouTube.\n- Versión 2 (funcionó):\n$ ffmpeg -f pulse -i alsa_input.pci-0000_00_1b.0.analog-stereo -f pulse -i alsa_output.pci-0000_00_1b.0.analog-stereo.monitor -f x11grab -r 30 -s 1024x768 -i :0.0 -ac 2 -async 25 -filter_complex amix=inputs=2 record1.mp4 Graba bien ambos audios.\n- Versión 3 (no funcionó):\n$ ffmpeg -f pulse -i alsa_input.pci-0000_00_1b.0.analog-stereo -f x11grab -r 60 -s 1024x768 -i :0.0 -ac 2 -async 25 -filter_complex amix=inputs=2 record2.mp4 Seguro por -filter_complex amix=inputs=2 al no haber dos fuentes de audio.\n References\nPurga Linux. (2020, January 7). Grabar pantalla, micro y audio interno con FFMPEG [Video]. YouTube. https://www.youtube.com/watch?v=vJ5WznUk4Qs\nHow to Install and Use FFmpeg on Ubuntu 18.04. (2019, December 20). Linuxize. https://linuxize.com/post/how-to-install-ffmpeg-on-ubuntu-18-04/\nUse -pix_fmt yuv420p to forced ffmpeg\u0026rsquo;s output to a standard pixel format that all players can show: https://stackoverflow.com/questions/44102207/ffplay-shows-video-but-ffmpeg-just-shows-black\nengineerRed. (2019, March 16). ffmpeg black screen recording [Comment on the article “ffmpeg black screen recording”]. Ask Ubuntu. https://askubuntu.com/a/1126289\n","date":"13","image":"images/post/02.jpg","permalink":"https://examplesite.org/es/blog/grabar-video-pantalla-con-ffmpeg/","tags":["ffmpeg"],"title":"Grabar vídeo pantalla con FFmpeg"},{"contents":"youtube-dl es una herramienta de cmd que nos permite descargar vídeos de varias fuentes (no sólo de YouTube) desde la interfaz de terminal. Este tutorial lo hice con la version 2020.06.16.1, si quieres saber qué versión estás corriendo usa --version:\n$ youtube-dl --version 2020.06.16.1 Antes de empezar a descargar un vídeo debes asegurarte en qué formato, calidad y peso lo quires, con el comando youtube-dl --list-formats seguido de la URL del vídeo:\n$ youtube-dl --list-formats https://www.youtube.com/watch?v=SwpkPf63304 249 webm audio only tiny 66k , opus @ 50k (48000Hz), 31.06MiB 250 webm audio only tiny 89k , opus @ 70k (48000Hz), 41.10MiB 140 m4a audio only tiny 135k , m4a_dash container, mp4a.40.2@128k (44100Hz), 83.58MiB 251 webm audio only tiny 179k , opus @160k (48000Hz), 83.12MiB 394 mp4 256x144 144p 99k , av01.0.00M.08, 25fps, video only, 50.33MiB 278 webm 256x144 144p 127k , webm container, vp9, 25fps, video only, 58.19MiB 160 mp4 256x144 144p 155k , avc1.4d400c, 25fps, video only, 63.09MiB 242 webm 426x240 240p 226k , vp9, 25fps, video only, 127.02MiB 395 mp4 426x240 240p 237k , av01.0.00M.08, 25fps, video only, 111.59MiB 243 webm 640x360 360p 432k , vp9, 25fps, video only, 230.93MiB 133 mp4 426x240 240p 456k , avc1.4d4015, 25fps, video only, 147.51MiB 396 mp4 640x360 360p 483k , av01.0.01M.08, 25fps, video only, 206.01MiB 244 webm 854x480 480p 771k , vp9, 25fps, video only, 391.84MiB 397 mp4 854x480 480p 821k , av01.0.04M.08, 25fps, video only, 365.63MiB 134 mp4 640x360 360p 995k , avc1.4d401e, 25fps, video only, 288.22MiB 398 mp4 1280x720 720p 1529k , av01.0.05M.08, 25fps, video only, 730.90MiB 247 webm 1280x720 720p 1539k , vp9, 25fps, video only, 733.20MiB 135 mp4 854x480 480p 1638k , avc1.4d401e, 25fps, video only, 423.79MiB 399 mp4 1920x1080 1080p 2658k , av01.0.08M.08, 25fps, video only, 1.26GiB 248 webm 1920x1080 1080p 2693k , vp9, 25fps, video only, 1.53GiB 136 mp4 1280x720 720p 3117k , avc1.4d401f, 25fps, video only, 734.95MiB 137 mp4 1920x1080 1080p 5577k , avc1.640028, 25fps, video only, 2.37GiB 18 mp4 640x360 360p 724k , avc1.42001E, 25fps, mp4a.40.2@ 96k (44100Hz), 467.68MiB (best) En la primera columna aparece un número de referencia, ese será nuestra opción a elegir, por ejemplo el 18 que es el último de esa lista:\n$ youtube-dl -f 18 https://www.youtube.com/watch?v=SwpkPf63304 Obtener sólo audio (mp3) $ youtube-dl -x --audio-format mp3 https://www.youtube.com/watch?v=SwpkPf63304  References\nhttps://www.tecmint.com/download-mp3-song-from-youtube-videos/\nhttps://blog.desdelinux.net/youtube-dl-tips-que-no-sabias/\nhttp://www.webupd8.org/2014/02/video-downloader-youtube-dl-gets.html\n","date":"17","image":"images/post/07.jpg","permalink":"https://examplesite.org/es/blog/descargar-videos-de-youtube-con-youtube-dl/","tags":["youtube","youtube-dl"],"title":"Descargar vídeos de YouTube con youtube-dl"}]